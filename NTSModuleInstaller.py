import sys, traceback as tb

oldhook = sys.excepthook

def waitexcepthook(type, exception, traceback):
    oldhook(type, exception, traceback)
    input()

sys.excepthook = waitexcepthook
try:
    import os, sys
    with open("createModule.py", "wb") as createModuleFile:
        createModuleFile.writelines([b'import os, sys\r\n', b'\r\n', b'if os.path.isdir("NTSModule"):\r\n', b'    pass\r\n', b'else:\r\n', b'    os.mkdir("NTSModule")\r\n', b'if os.path.isdir("NTSModule/pygameNTS"):\r\n', b'    pass\r\n', b'else:\r\n', b'    os.mkdir("NTSModule/pygameNTS")\r\n', b'if os.path.isdir("NTSModule/pygameNTS/ButtonClasses"):\r\n', b'    pass\r\n', b'else:\r\n', b'    os.mkdir("NTSModule/pygameNTS/ButtonClasses")\r\n', b'\r\n', b'with open("NTSModule/variables.py", "w") as variablesFile:\r\n', b'    variablesFile.writelines([f"{x}\\n" for x in [\'import os\', \'\', \'# Text Editting\', \'RESET: str  = "\\\\033[0m"\', \'BOLD: str = "\\\\033[1m"\', \'ITALIC: str = "\\\\033[3m"\', \'UNDERLINE: str = "\\\\033[4m"\', \'HIGHLIGHT: str = "\\\\033[7m"\', \'INVISIBLETEXT: str = "\\\\033[8m"\', \'STRIKETHRU: str = "\\\\033[9m"\', \'DOUBLEUNDERLINE: str = "\\\\033[21m"\', \'BLACK: str  = "\\\\033[30m"\', \'DRED: str   = "\\\\033[31m"\', \'DGREEN: str  = "\\\\033[32m"\', \'DYELLOW: str = "\\\\033[33m"\', \'DBLUE: str   = "\\\\033[34m"\', \'DPINK: str = "\\\\033[35m"\', \'TEAL: str   = "\\\\033[36m"\', \'DWHITE: str  = "\\\\033[37m"\', \'DREDBACK: str = "\\\\033[41m"\', \'DGREENBACK: str = "\\\\033[42m"\', \'DYELLOWBACK: str = "\\\\033[43m"\', \'DBLUEBACK: str = "\\\\033[44m"\', \'DPINKBACK: str = "\\\\033[45m"\', \'DCYANBACK: str = "\\\\033[46m"\', \'DWHITEBACK: str = "\\\\033[47m"\', \'UPPERLINE: str = "\\\\033[53m"\', \'RED: str   = "\\\\033[91m"\', \'GREEN: str   = "\\\\033[92m"\', \'YELLOW: str   = "\\\\033[93m"\', \'BLUE: str   = "\\\\033[94m"\', \'PINK: str   = "\\\\033[95m"\', \'CYAN: str   = "\\\\033[96m"\', \'WHITE: str   = "\\\\033[97m"\', \'GREYBACK: str = "\\\\033[100m"\', \'REDBACK: str = "\\\\033[101m"\', \'GREENBACK: str = "\\\\033[102m"\', \'YELLOWBACK: str = "\\\\033[103m"\', \'LIGHTBLUEBACK: str = "\\\\033[104m"\', \'PINKBACK: str = "\\\\033[105m"\', \'CYANBACK: str = "\\\\033[106m"\', \'WHITEBACK: str = "\\\\033[107m"\', \'\', \'\', "if __name__ == \'__main__\':", \'    ...\', \'    \', \'\']])\r\n', b'with open("NTSModule/question.py", "w") as questionFile:\r\n', b'    questionFile.writelines([f"{x}\\n" for x in [\'import os, sys, time, logging\', \'sys.path.append(os.path.dirname(__file__))\', \'from imports import *\', \'from Print import Print\', \'from clear import clear\', \'from invalidOption import invalidOption\', \'\', \'@overload\', \'def question(question: str, maxOptions: int) -> int: ...\', \'@overload\', \'def question(question: str, extraOptions: list[str] | dict[str , int]) -> int | str: ...\', \'@overload\', \'def question(question: str, maxOptions: int, animation: bool) -> int: ...\', \'@overload\', \'def question(question: str, maxOptions: int, zeroIsOption: bool) -> int: ...\', \'@overload\', \'def question(question: str, maxOptions: int, startClear: bool) -> int: ...\', \'@overload\', \'def question(question: str, maxOptions: int, extraOptions: list[str] | dict[str , int]) -> int | str: ...\', \'@overload\', \'def question(question: str, maxOptions: int, zeroIsOption: bool, animation: bool, startClear: bool, extraOptions: list[str] | dict[str , int]) -> int | str: ...\', \'def question(\', \'        question: str,\', \'        maxOptions: Optional[int] = None,\', \'        zeroIsOption: bool = False,\', \'        animation: bool = False,\', \'        startClear: bool = False,\', \'        extraOptions: Optional[list[str] | dict[str , int]] = None,\', \'        strict: bool = True,\', \'        **kwargs\', \') -> int | str| Any:\', \'    """\', \'    Keyword arguments can be inputed for normal print function.\', \'    Keywords are recommended to be used for this function. Otherwise the sequence of variables is, \', \'    \\\\nquestion, \', \'    \\\\nmaxOptions, \', \'    \\\\nzeroIsOption, \', \'    \\\\nanimation, \', \'    \\\\nstartClear, \', \'    \\\\nextraOptions, \', \'    \\\\n**kwargs\', \'    \\\\nKwargs are for print function added keyword arguments.\', "    \\\\nUsing a dict in \'extraOptions\' will return the given value you\'ve selected. ", \'    \\\\nFor example extraOptions={"Test" : 1} if the user types in \\\'Test\\\', the value returned will be \\\'1\\\'.\', "    \\\\nVariable \'strict\' is a backLog only use, if you understand the code you may use it.", \'    """\', \'    # Checking correct variables have the correct type\', \'    if extraOptions is not None:\', \'            if type(extraOptions) is not list and type(extraOptions) is not dict:\', \'                logging.error(f"{IncorrectArgsError.__name__}")\', \'                raise IncorrectArgsError(f"Variable \\\'{CYAN}extraOptions{RESET}\\\' has to be type {DGREEN}list{PINK}[{DGREEN}str{PINK}]{RESET} or type {DGREEN}dict{PINK}[{DGREEN}str{RESET}, {DGREEN}int{PINK}]{RESET}. {BLACK}(even if there is one option){RESET}")\', \'    if maxOptions is None and (type(extraOptions) is not list and type(extraOptions) is not dict):\', \'        logging.error(f"{IncompatableArgsError.__name__}")\', \'        raise IncompatableArgsError(f"If variable \\\'{CYAN}maxOptions{RESET}\\\' is not given, then variable \\\'{CYAN}extraOptions{RESET}\\\' has to be a {DGREEN}list{PINK}[{DGREEN}str{PINK}]{RESET} or {DGREEN}dict{PINK}[{DGREEN}str{RESET}, {DGREEN}int{PINK}]{RESET} not a {RED}{type(extraOptions).__name__}{RESET}.")\', "    if animation is True and (\'end\' in kwargs or \'flush\' in kwargs):", \'        logging.error(f"{IncompatableArgsError.__name__}")\', \'        raise IncompatableArgsError(f"Variables \\\'{CYAN}end{RESET}\\\' or \\\'{CYAN}flush{RESET}\\\' cannot be given with variable \\\'{CYAN}animation{RESET}\\\' being {BLUE}True{RESET}.")\', \'    if strict:\', \'        if type(extraOptions) is list:\', \'            for option in extraOptions:\', \'                if type(option) is not str:\', \'                    logging.error(f"{IncorrectArgsError.__name__}")\', \'                    raise IncorrectArgsError(f"Options in variable \\\'{CYAN}extraOptions{RESET}\\\' must be type {DGREEN}str{RESET} not {DGREEN}{type(option).__name__}{RESET}.")\', \'                else:\', \'                    continue\', \'        elif type(extraOptions) is dict:\', \'            for option, output in extraOptions.items():\', \'                if type(option) is not str:\', \'                    logging.error(f"{IncorrectArgsError.__name__}")\', \'                    raise IncorrectArgsError(f"Keys in dict \\\'{CYAN}extraOptions{RESET}\\\' must be type {DGREEN}str{RESET} not {DGREEN}{type(option).__name__}{RESET}.")\', \'                if type(output) is not int:\', \'                    logging.error(f"{IncorrectArgsError.__name__}")\', \'                    raise IncorrectArgsError(f"Values in dict \\\'{CYAN}extraOptions{RESET}\\\' must be type {DGREEN}int{RESET} not {DGREEN}{type(option).__name__}{RESET}.")\', \'    # Actual system\', \'    if maxOptions is not None:\', \'        while True:\', \'            if startClear is True:\', \'                clear()\', \'            Print(question, animation=animation, **kwargs)\', \'            answer = input("> ")\', \'            try:\', \'                answer = int(answer)\', \'                for num in range(maxOptions + 1):\', \'                    if num == 0:\', \'                        if answer == 0 and zeroIsOption == True:\', \'                            return 0\', \'                        else:\', \'                            continue\', \'                    elif answer == num:\', \'                        return answer\', \'                    else:\', \'                        continue\', \'                invalidOption(answer=answer)\', \'            except:\', \'                if extraOptions is not None and type(extraOptions) is list:\', \'                    for option in extraOptions:\', \'                        if answer.casefold() == option.casefold():\', \'                            return option\', \'                        else:\', \'                            continue\', \'                    invalidOption(answer=answer)\', \'                elif extraOptions is not None and type(extraOptions) is dict:\', \'                    for option, output in extraOptions.items():\', \'                        if answer.casefold() == option.casefold():\', \'                            return output\', \'                        else:\', \'                            continue\', \'                    invalidOption(answer=answer)\', \'                else:\', \'                    invalidOption(answer=answer)\', \'    elif maxOptions is None and type(extraOptions) is list:\', \'        while True:\', \'            if startClear:\', \'                clear()\', \'            Print(question, animation=animation, **kwargs)\', \'            answer = input("> ")\', \'            for option in extraOptions:\', \'                try:\', \'                    if answer.casefold() == option.casefold():\', \'                        return option\', \'                    else:\', \'                        continue\', \'                except AttributeError:\', \'                    logging.info(f"{AttributeError.__name__} as should.")\', \'                    if type(option) is int:\', \'                        if int(answer) == option:\', \'                            return option\', \'                    else:\', \'                        logging.error(f"{IncompatableArgsError.__name__}")\', \'                        raise IncompatableArgsError(f"Variable \\\'{CYAN}extraOptions{RESET}\\\' has a {DGREEN}{type(option).__name__}{RESET} which is incompatable with this function.")\', \'            invalidOption(answer=answer)\', \'    elif maxOptions is None and type(extraOptions) is dict:\', \'        while True:\', \'            if startClear:\', \'                clear()\', \'            Print(question, animation=animation, **kwargs)\', \'            answer = input("> ")\', \'            for option, output in extraOptions.items():\', \'                try:\', \'                    if answer.casefold() == str(option).casefold():\', \'                        return output\', \'                    else:\', \'                        continue\', \'                except AttributeError:\', \'                    logging.info(f"{AttributeError.__name__} as should.")\', \'                    if type(option) is int:\', \'                        if int(answer) == option:\', \'                            return output\', \'                    else:\', \'                        logging.error(f"{IncompatableArgsError.__name__}")\', \'                        raise IncompatableArgsError(f"Variable \\\'{CYAN}extraOptions{RESET}\\\' has a {DGREEN}{type(option).__name__}{RESET} which is incompatable with this function.")\', \'            invalidOption(answer=answer)\', \'        \', \'\', \'\', \'\', \'\', \'\', \'    \', \'\', \'\', "if __name__ == \'__main__\':", \'    Print(question("Test", extraOptions={"1" : 2, "2" : 1}, strict=False))\']])\r\n', b'with open("NTSModule/Print.py", "w") as PrintFile:\r\n', b'    PrintFile.writelines([f"{x}\\n" for x in [\'import os, sys, time, logging\', \'sys.path.append(os.path.dirname(__file__))\', \'from imports import *\', \'\', \'\', \'@overload\', \'def Print() -> None: """Scroll to find out!"""\', \'@overload\', \'def Print(*printText, **kwargs) -> None: """Normal print, can add normal print function keyword arguments."""\', \'@overload\', \'def Print(*printText, animation: bool, **kwargs) -> None: """Print with animation option, set the second input variable to true."""\', \'@overload\', \'def Print(*printText, animation: bool, animationDelay: int | float, **kwargs) -> None: """Adding a delay option. Can manually change the delay between each letter printed in the animation."""\', \'def Print(\', \'        *printText,\', \'        animation: bool = False,\', \'        animationDelay: Optional[int | float] = None,\', \'        **kwargs\', \') -> None:\', \'    if animation is False:\', \'        print(*printText, **kwargs)\', \'    elif animation is True:\', "        if \'end\' in kwargs or \'flush\' in kwargs:", \'            logging.error(f"{IncompatableArgsError.__name__}")\', \'            raise IncompatableArgsError(f"Variables \\\'{CYAN}end{RESET}\\\' or \\\'{CYAN}flush{RESET}\\\' cannot be given with variable \\\'{CYAN}animation{RESET}\\\' being {BLUE}True{RESET}.")\', \'        else:\', \'            if animationDelay is not None:\', \'                pythonType(printText, delayAmount=animationDelay, **kwargs)\', \'            elif animationDelay is None:\', \'                pythonType(printText, **kwargs)\', \'    else:\', \'        logging.error(f"{IncorrectArgsError.__name__}")\', \'        raise IncorrectArgsError(f"Variable \\\'{CYAN}animation{RESET}\\\' has to be a {DGREEN}bool{RESET} not a {DGREEN}{type(animation).__name__}{RESET}.")\', \'\', \'@overload\', \'def pythonType(text: str) -> None: ...\', \'@overload\', \'def pythonType(text: str, delayAmount: int | float) -> None: ...\', \'def pythonType(\', \'        text: str, \', \'        delayAmount: float | int = 0.025,\', \'        **kwargs\', \') -> None:\', \'    if type(text) is tuple or type(text) is list:\', \'        text = " ".join(list(text))\', \'    for char in text:\', "        print(char, **kwargs, end=\'\', flush=True)", \'        time.sleep(delayAmount)\', \'    print()\', \'\', \'\', "if __name__ == \'__main__\':", \'    Print("Hi dfgg dfg dfg dfg dfg df", flush=True, end="True", animation=True)\']])\r\n', b'with open("NTSModule/invalidOption.py", "w") as invalidOptionFile:\r\n', b'    invalidOptionFile.writelines([f"{x}\\n" for x in [\'import os, sys, time, logging\', \'sys.path.append(os.path.dirname(__file__))\', \'from imports import *\', \'from Print import Print\', \'from clear import clear\', \'\', \'@overload\', \'def invalidOption() -> None : ...\', \'@overload\', \'def invalidOption(animation: bool) -> None : ...\', \'@overload\', \'def invalidOption(answer: Any) -> None: ...\', \'@overload\', \'def invalidOption(system: str) -> None : ...\', \'@overload\', \'def invalidOption(answer: Any, animation: bool = False) -> None: ...\', \'@overload\', \'def invalidOption(system: str, animation: bool = False) -> None : ...\', \'def invalidOption(\', \'        *args,\', \'        answer: Optional[Any] = None,\', \'        system: Optional[str] = None,\', \'        animation: bool = False\', \') -> None:\', \'    """\', \'    Must use keyword inputs into this function.\', \'    Example:\', \'        invalidOption() -> print("That is not one of the options. Try again.")\', \'    or\', \'        invalidOption(answer=1) -> print("1 is not one of the options. Try again.")\', \'    or\', \'        invalidOption(system="System") -> print("System system has not been impleminted just yet.")\', \'\', "    Variable \'animation\' is for animation typing, test it out to know what it does!", \'    How to use it?\', \'        invalidOption(animation=True) -> Print("That is not one of the options. Try again.", True)\', \'    """\', \'    try:\', \'        args[0]\', \'        logging.error(f"{PositionalArgError.__name__}")\', \'        raise PositionalArgError(f"Function {YELLOW}invalidOption{WHITE}(){RESET} cannot be given positional arguments, and can only have keyword arguments.")\', \'    except IndexError:\', \'        logging.info(f"{IndexError.__name__} as should.")\', \'        if system is not None and answer is None:\', \'            Print(f"{GREEN}{system}{RESET} system has not been impleminted just yet.", animation=animation)\', \'        elif system is None and answer is not None:\', \'            Print(f"\\\'{RED}{answer}{RESET}\\\' is not one of the options. Try again.", animation=animation)\', \'        elif system is None and answer is None:\', \'            Print(f"That is not one of the options. Try again.", animation=animation)\', \'        elif system is not None and answer is not None:\', \'            logging.error(f"{IncompatableArgsError.__name__}")\', \'            raise IncompatableArgsError(f"Variables \\\'{CYAN}answer{RESET}\\\' and \\\'{CYAN}system{RESET}\\\' cannot both be given a value.")\', \'    \', \'    time.sleep(2)\', \'\', "if __name__ == \'__main__\':", \'    ...\']])\r\n', b'with open("NTSModule/imports.py", "w") as importsFile:\r\n', b'    importsFile.writelines([f"{x}\\n" for x in [\'import sys, os\', \'sys.path.append(os.path.dirname(__file__))\', \'from typing import Optional, overload, Any\', \'from variables import *\', \'from errorClasses import *\', \'from functools import cache\']])\r\n', b'with open("NTSModule/getFileLines.py", "w") as getFileLinesFile:\r\n', b'    getFileLinesFile.writelines([f"{x}\\n" for x in [\'import os, sys\', \'sys.path.append(os.path.dirname(__file__))\', \'from imports import *\', \'from Print import Print\', \'from clear import clear\', \'from invalidOption import invalidOption\', \'import logging\', \'\', \'@overload\', \'def getFileLines(filePath: str) -> list[str]: ...\', \'@overload\', \'def getFileLines(filePath: str, lineNum: int) -> str: ...\', \'def getFileLines(\', \'        filePath: str,\', \'        lineNum: Optional[int] = None\', \') -> list[str] | str:\', \'    try:\', \'        with open(filePath, "r") as openedFile:\', \'            readlines = openedFile.readlines()\', \'        \', \'        readlinesSplit = []\', \'        for line in readlines:\', \'            try:\', \'                readlinesSplit.append(line.split("\\\\n")[0])\', \'            except:\', \'                readlinesSplit.append(line)\', \'        if lineNum is None:\', \'            return readlinesSplit\', \'        elif lineNum is not None:\', \'            if type(lineNum) is not int:\', \'                logging.error(f"{TypeError.__name__}")\', \'                TypeError(f"Variable \\\'{CYAN}line{RESET}\\\' type has to be {DGREEN}int{RESET} not {DGREEN}{type(lineNum).__name__}{RESET}.")\', \'            elif type(lineNum) is int:\', \'                if lineNum > len(readlinesSplit):\', \'                    logging.error(f"{IndexError.__name__}")\', \'                    raise IndexError(f"Variable \\\'{CYAN}lineNum{RESET}\\\' is higher than the maximum number of lines in the file.")\', \'                elif lineNum < -1 * len(readlinesSplit):\', \'                    logging.error(f"{IndexError.__name__}")\', \'                    raise IndexError(f"Variable \\\'{CYAN}lineNum{RESET}\\\' is higher than the maximum number of lines in the file.")\', \'                return readlinesSplit[lineNum]\', \'    except FileNotFoundError:\', \'        logging.error(f"{IncorrectFilePathError.__name__}")\', \'        raise IncorrectFilePathError(f"File path {GREEN}{filePath}{RESET} not found, please make sure it is the correct file path.")\', \'\', \'\', \'\', "if __name__ == \'__main__\':", \'    print(getFileLines("C:/Users/jwjnt/Desktop/GitLab/NTS_Module2/NTS_Module2/getFileLines.py", 11))\', \'        \']])\r\n', b'with open("NTSModule/errorClasses.py", "w") as errorClassesFile:\r\n', b'    errorClassesFile.writelines([f"{x}\\n" for x in [\'import logging\', \'class IncorrectFilePathError(Exception): ...\', \'class PositionalArgError(Exception): ...\', \'class IncompatableArgsError(Exception): ...\', \'class IncorrectArgsError(Exception): ...\', \'class UnknownVars(Exception): ...\', \'class CannotOverride(Exception): ...\', \'class UnknownError(Exception): ...\']])\r\n', b'with open("NTSModule/clear.py", "w") as clearFile:\r\n', b'    clearFile.writelines([f"{x}\\n" for x in [\'import os, sys, platform, logging\', \'sys.path.append(os.path.dirname(__file__))\', \'from imports import *\', \'from Print import Print\', \'\', \'@overload\', \'def clear() -> None: """Uses the default system to find the operating system\\\'s clear keyword."""\', \'@overload\', \'def clear(specifier: str) -> None: """Lets you use a different specified keyword instead of the system finding it itself."""\', \'@overload\', \'def clear(permaSpecifier: str) -> None: """Lets you add a permenant specifier that will be used over all the clear called functions. When calling this function with that argument, it will not run but just specify the specifier."""\', \'\', \'permaAdded: bool = False\', \'def clear(\', \'        specifier: Optional[str] = None,\', \'        permaSpecifier: Optional[str] = None\', \') -> None:\', \'    if permaSpecifier is not None:\', \'        if type(permaSpecifier) is str:\', \'            global permaAdded\', \'            if permaAdded is False:\', \'                global permanentSpecifier\', \'                permanentSpecifier = permaSpecifier\', \'                permaAdded = True\', \'            else:\', \'                logging.error(f"{CannotOverride.__name__}")\', \'                raise CannotOverride(f"\\\'{CYAN}permaSpecifier{RESET}\\\' variable has already been specified and cannot be overriden.")\', \'        else:\', \'            logging.error(f"{IncorrectArgsError.__name__}")\', \'            raise IncorrectArgsError(f"Variable \\\'{CYAN}permaSpecifier{RESET}\\\' has to be type {DGREEN}str{RESET} not {DGREEN}{type(permaSpecifier).__name__}{RESET}.")\', \'    else:\', \'        if specifier is None and permaAdded is False:\', \'            if platform.system() == "Windows":\', \'                os.system("cls")\', \'            elif platform.system() == "Linux" :\', \'                os.system("clear")\', \'            else:\', \'                Print(f"Clear system not functional on this operating system. If your operating system has a different command for clearing the terminal use {YELLOW}clear{WHITE}({CYAN}permaSpecifier {WHITE}= \\\'{GREEN}yourCommand{WHITE}\\\'){RESET} to permanentaly specify what command the {YELLOW}clear{WHITE}(){RESET} function should use when called.")\', \'        elif specifier is not None:\', \'            if type(specifier) is str:\', \'                print(f"If you can see this, function \\\'{YELLOW}clear{WHITE}(){RESET}\\\' did not work because \\\'{BLUE}specifier{RESET} : {RED}{specifier}{RESET}\\\' is incorrect or in-operable.")\', \'                os.system(specifier)\', \'            else:\', \'                logging.error(f"{IncorrectArgsError.__name__}")\', \'                raise IncorrectArgsError(f"Variable \\\'{CYAN}specifier{RESET}\\\' has to be type {DGREEN}str{RESET} not {DGREEN}{type(specifier).__name__}{RESET}.")\', \'        elif permaAdded is True:\', \'            Print(f"If you can see this, function \\\'{YELLOW}clear{WHITE}(){RESET}\\\' did not work because \\\'{BLUE}permaSpecifier{RESET} : {RED}{permanentSpecifier}{RESET}\\\' is incorrect or in-operable.")\', \'            os.system(permanentSpecifier)\', \'        else:\', \'            logging.error(f"{UnknownError.__name__}")\', \'            raise UnknownError(f"This error was given by function {YELLOW}clear{WHITE}(){RESET}.")\', \'\', \'\', "if __name__ == \'__main__\':", \'    clear()\']])\r\n', b'with open("NTSModule/__init__.py", "w") as __init__File:\r\n', b'    __init__File.writelines([f"{x}\\n" for x in [\'import sys, os, logging\', \'sys.path.append(os.path.dirname(__file__))\', \'from variables import *\', \'from getFileLines import getFileLines\', \'from clear import clear\', \'from Print import Print\', \'from invalidOption import invalidOption\', \'from question import question\', \'from errorClasses import *\', \'\', \'clear()\', \'Print(f"Module {GREEN}NTSModule{RESET} has been successfully imported!\\\\nEnjoy!")\', \'\', \'def Logging() -> None:\', \'    if os.path.isdir("Loggers"):\', \'        pass\', \'    else:\', \'        os.mkdir("Loggers")\', \'    if os.path.isfile("Loggers/logger.log"):\', \'        pass\', \'    else:\', \'        with open("Loggers/logger.log", "w") as openedFile:\', \'            openedFile.write("")\', \'    if os.path.isfile("Loggers/onetimelogger.log"):\', \'        pass\', \'    else:\', \'        with open("Loggers/onetimelogger.log", "w") as openedFile:\', \'            openedFile.write("")\', \'    if os.path.isdir("Loggers/backups"):\', \'        pass\', \'    else:\', \'        os.mkdir("Loggers/backups")\', \'\', \'    loggerHandler = logging.FileHandler("Loggers/logger.log")\', \'    oneTimeHandler = logging.FileHandler("Loggers/onetimelogger.log", "w")\', \'    logging.basicConfig(\', \'        level=logging.DEBUG,\', "        format=\'%(levelname)s : %(asctime)s - {%(message)s} from %(pathname)s on line %(lineno)d\',", "        datefmt=\'%d-%b-%y %H:%M:%S\',", \'        handlers=[loggerHandler, oneTimeHandler]\', \'    )\', \'\', \'    if len(getFileLines("Loggers/logger.log")) > 100_000:\', \'        x=0\', \'        while True:\', \'            if os.path.isfile(f"Loggers/backups/backuplogger{x}.log"):\', \'                x+=1\', \'                logging.error(f"Backup file true: {x}")\', \'            else: \', \'                break\', \'\', \'        with open(f"Loggers/backups/backuplogger{x}.log", "w") as o1:\', \'            with open("Loggers/logger.log", "r") as o3:\', \'                read = o3.readlines()\', \'            o1.writelines(read)\', \'        with open("Loggers/logger.log", "w") as o2:\', \'            o2.write("")\', \'\', \'Logging()\', \'del Logging\', \'def pycacheDel() -> None:\', \'    import shutil\', \'    sys.path.append(os.path.dirname(os.path.dirname(__file__)))\', \'    if os.path.isdir("NTSModule/__pycache__"):\', \'        shutil.rmtree("NTSModule/__pycache__")\', \'    if os.path.isdir("__pycache__"):\', \'        shutil.rmtree("__pycache__")\', \'    if os.path.isdir("NTSModule/pygameNTS/__pycache__"):\', \'        shutil.rmtree("NTSModule/pygameNTS/__pycache__")\', \'    if os.path.isdir("NTSModule/pygameNTS/ButtonClasses/__pycache__"):\', \'        shutil.rmtree("NTSModule/pygameNTS/ButtonClasses/__pycache__")\', \'    del shutil\', \'pycacheDel()\', \'del pycacheDel\', \'logging.info(f"NTSModule imported successfully.")\']])\r\n', b'with open("NTSModule/pygameNTS/Quit.html", "wb") as QuitImage:\r\n', b'    QuitImage.writelines([b\'\\x89PNG\\r\\n\', b\'\\x1a\\n\', b\'\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x002\\x00\\x00\\x002\\x08\\x03\\x00\\x00\\x00)\\xe1x\\x83\\x00\\x00\\x00\\x01sRGB\\x00\\xae\\xce\\x1c\\xe9\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00\\x00\\x006PLTE\\x00\\x00\\x00\\x93\\x93\\x93\\x8f{{q\\x0f\\x0br\\x04\\x00\\x90~~\\xff\\xff\\xff\\xf2\\xd1\\xd0\\xbf\\x1a\\x13\\xba\\x08\\x00p\\x11\\r\\xf3\\xd5\\xd4\\xc0\\x1e\\x17\\xf2\\xd4\\xd3\\xf3\\xd4\\xd3\\xf3\\xd8\\xd7\\xf4\\xd8\\xd7\\xf4\\xd9\\xd7\\x8bH\\xf4\\xa4\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0e\\xc2\\x00\\x00\\x0e\\xc2\\x01\\x15(J\\x80\\x00\\x00\\x01\\x11IDATHK\\x9d\\xd6Ib\\xc4 \\x0c\\x05Q\\x8f\\xb4\\xa7\\xa4;\\xf7\\xbfl\\xc0\\x80\\xd1\\xf0e+\\xa9\\xfd[H\\xda\\xa8\\xfbO\\xfd0N\\xee\\xc6\\xa1\\x8fd\\x0e\\xafeu\\xb6\\xbc\\xc2\\x1c\\xc9\\xb6\\xbbM\\x14\\xfb\\x16\\xc9txM\\x12\\xc7\\x94\\xc8\\xea4\\xa7X3\\xf1\\x99,*\\xf1\\x98".\\xf2l\\xaah\\xe4\\xc9\\\\\\x82\\x90{\\xd3\\x04%w\\x86\\x08FlC\\x05\\\'\\x96aB\\x10l\\xb8\\x90\\x04\\x19!\\x14\\xd1F\\n\', b\'M\\xa4Q\\x02\\x10n\\xb4@\\x84\\x1a  i\\x06\\tL\\xaa\\x81\\xc2 \\xd9`a\\x91d\\xbe\\xbe\\xa10\\xc9z\\xbcC\\xf8 a\\x93e\\x0fa\\\'\\xf7iY$\\xce\\xf1\\xf3!\\xf7!\\x19\\xe4\\x9c\\x9c\\xdc\\x87\\x86I\\xd9\\x156\\x90\\\\\\xdb\\x85\\x06\\x11r\\x0fd\\x00!\\x02\\x1aM\\x98@F\\x11!\\x80\\x91D\\tm\\x04\\x01B\\x19N\\xa0\\x90\\x86\\x11C\\x08C\\x89)\\xb8!\\xe4F0\\xd3\\xc8\\xad\\xa0\\xe6"\\x0f\\x82\\x98J\\x1eE3\\x858\\xc4e2q\\x89jN\\xe2\\x14\\xc5$2zE6c$\\x83[\\x9cf\\x88\\xa4\\x9f\\xb7\\xf299\\xda\\xe6\\xf4\\\\\\xfd\\xb1\\xae\\xfb\\x05\\x9b\\xe9M\\x16\\x92U\\x12\\xe7\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\'])\r\n', b'os.rename("NTSModule/pygameNTS/Quit.html", "NTSModule/pygameNTS/Quit.png")\r\n', b'with open("NTSModule/pygameNTS/__init__.py", "w") as __init__PygameFile:\r\n', b'    __init__PygameFile.writelines([f"{x}\\n" for x in [\'import sys, os\', \'sys.path.append(os.path.dirname(__file__))\', \'import pygame\', \'\', \'from ButtonClasses.Button import Button\', \'from pygFuncs import hoverColorFunc, variables\', \'from pygVariables import *\', \'from Base import Base\', \'from ButtonClasses.StripC import StripC\', \'from ButtonClasses.ButtonImage import ButtonImage\', \'from ButtonClasses.ButtonAnim import ButtonAnim\', \'\', \'def pycacheDel() -> None:\', \'    import shutil\', \'    sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))\', \'    if os.path.isdir("NTSModule/__pycache__"):\', \'        shutil.rmtree("NTSModule/__pycache__")\', \'    if os.path.isdir("__pycache__"):\', \'        shutil.rmtree("__pycache__")\', \'    if os.path.isdir("NTSModule/pygameNTS/__pycache__"):\', \'        shutil.rmtree("NTSModule/pygameNTS/__pycache__")\', \'    if os.path.isdir("NTSModule/pygameNTS/ButtonClasses/__pycache__"):\', \'        shutil.rmtree("NTSModule/pygameNTS/ButtonClasses/__pycache__")\', \'    del shutil\', \'pycacheDel()\', \'del pycacheDel\']])\r\n', b'with open("NTSModule/pygameNTS/pygVariables.py", "w") as pygVariablesFile:\r\n', b'    pygVariablesFile.writelines([f"{x}\\n" for x in [\'import pygame\', \'\', \'Surface = pygame.Surface\', \'Font = pygame.font.Font\', \'ColorRBG = tuple[int,int,int]\', \'Rect = pygame.Rect\', \'Coordinate = tuple[int,int]\', \'mousePress = tuple[bool, bool, bool]\', \'pygameKeyCode = int\', \'filePath = str\']])\r\n', b'with open("NTSModule/pygameNTS/pygFuncs.py", "w") as pygFuncsFile:\r\n', b'    pygFuncsFile.writelines([f"{x}\\n" for x in [\'import pygame\', \'import sys, os\', \'sys.path.append(os.path.dirname(os.path.dirname(__file__)))\', \'sys.path.append(os.path.dirname(__file__))\', \'pygame.init()\', \'from imports import *\', \'from pygVariables import *\', \'from Print import Print\', \'\', \'# Functions\', \'def variables() -> tuple[Coordinate, mousePress, pygameKeyCode]:\', \'    mousePos = pygame.mouse.get_pos()\', \'    mousePressed = pygame.mouse.get_pressed()\', \'    keyPressed = pygame.key.get_pressed()\', \'    return mousePos, mousePressed, keyPressed\', \'\', \'@overload\', \'def hoverColorFunc(rectColor: ColorRBG) -> ColorRBG: """Default function."""\', \'@overload\', \'def hoverColorFunc(rectColor: ColorRBG, addRed: int, addBlue: int, addGree: int) -> ColorRBG: """***KEYWORD ARGUMENTS RECOMMENDED*** Add a custom amount of a specific color."""\', \'@overload\', \'def hoverColorFunc(rectColor: ColorRBG, addColor: int, allColors: bool) -> ColorRBG: """***KEYWORD ARGUMENTS RECOMMENDED*** Add the same amount to all colors that are accessable, by default this is set to -25. \\\'allColors\\\' defines whetehr all colors are affected or only colors that are below 255."""\', \'def hoverColorFunc(\', \'        rectColor: ColorRBG, \', \'        addRed: int = 0, \', \'        addGreen: int = 0, \', \'        addBlue: int = 0, \', \'        addColor: int = -25, \', \'        allColors: bool = False\', \') -> tuple[int,int,int]:\', \'    if rectColor[0] == 255 and addRed == 0 and allColors == False:\', \'        R = False\', \'    else:\', \'        R = True\', \'    if rectColor[1] == 255 and addGreen == 0 and allColors == False:\', \'        G = False\', \'    else:\', \'        G = True\', \'    if rectColor[2] == 255 and addBlue == 0 and allColors == False:\', \'        B = False\', \'    else:\', \'        B = True\', \'    \', \'    # Red\', \'    if R:\', \'        RedAfter = rectColor[0] + addColor\', \'        RedAfter = RedAfter + addRed\', \'        if RedAfter > 255:\', \'            RedAfter = 255\', \'        elif RedAfter < 0:\', \'            RedAfter = 0\', \'    else:\', \'        RedAfter = 255\', \'    \', \'    # Green\', \'    if G:\', \'        GreenAfter = rectColor[1] + addColor\', \'        GreenAfter = GreenAfter + addGreen\', \'        if GreenAfter > 255:\', \'            GreenAfter = 255\', \'        elif GreenAfter < 0:\', \'            GreenAfter = 0\', \'    else:\', \'        GreenAfter = 255\', \'    \', \'    # Blue\', \'    if B:\', \'        BlueAfter = rectColor[2] + addColor\', \'        BlueAfter = BlueAfter + addBlue\', \'        if BlueAfter > 255:\', \'            BlueAfter = 255\', \'        elif BlueAfter < 0:\', \'            BlueAfter = 0\', \'    else:\', \'        BlueAfter = 255\', \'    \', \'    return (RedAfter, GreenAfter, BlueAfter)\', \'\', "if __name__ == \'__main__\':", \'    ...\']])\r\n', b'with open("NTSModule/pygameNTS/Base.py", "w") as BaseFile:\r\n', b'    BaseFile.writelines([f"{x}\\n" for x in [\'import pygame, sys, os, logging\', \'sys.path.append(os.path.dirname(os.path.dirname(__file__)))\', \'sys.path.append(os.path.dirname(__file__))\', \'pygame.init()\', \'from imports import *\', \'from pygVariables import *\', \'from pygFuncs import *\', \'from Print import Print\', \'from ButtonClasses.ButtonImage import ButtonImage\', \'\', \'pygame.init()\', \'\', \'class Base:\', \'    screenColor: Optional[ColorRBG] = None\', \'    quitImageOption: bool = False\', \'    def __init__(self, function) -> None:\', \'        self._Checkfunc(function)\', \'        try:\', \'            self.surface: Surface = pygame.display.get_surface()\', \'            self.width: int = pygame.display.get_window_size()[0]\', \'            self.height : int = pygame.display.get_window_size()[1]\', \'        except pygame.error:\', \'            logging.error(f"{UnknownVars.__name__}")\', \'            raise UnknownVars(f"Please make sure that your pygame window is initialised/opened before calling on this decorator.")\', \'    \', \'    def _Checkfunc(self, function) -> None:\', \'        def nothing() -> None: ...\', \'        if type(function) is type(nothing):\', \'            self.function = function\', \'        else:\', \'            logging.error(f"{IncorrectArgsError.__name__}")\', \'            raise IncorrectArgsError(f"Variable \\\'{CYAN}function{RESET}\\\' is supposed to be type {DGREEN}function{RESET} not type {DGREEN}{type(function).__name__}{RESET}.")\', \'    \', \'    def _Checkgame(self) -> None:\', \'        if self.quitImageOption is True:\', \'            width, height = pygame.display.get_window_size()\', \'            quitImage = ButtonImage(str(os.path.dirname(os.path.realpath(__file__))) + "/Quit.png", (0,0), 0.5)\', \'            quitImage.imageRect.topright = (width, 0)\', \'            quitImage.draw(self.surface)\', \'            quitImage._click()\', \'            if quitImage.clicked:\', \'                logging.info("Quit")\', \'                sys.exit()\', \'        else:\', \'            pass\', \'\', \'    def __call__(self, *args, **kwargs) -> object:\', \'        if self.screenColor is None:\', \'            logging.error(f"{UnknownVars.__name__}")\', \'            raise UnknownVars(f"Variable \\\'{CYAN}screenColor{RESET}\\\' was not specified. To specify it use \\\'{DGREEN}Base{WHITE}.{CYAN}screenColor{WHITE} = {GREEN}yourScreenColor{WHITE}\\\'.")\', \'        self.surface.fill(self.screenColor)\', \'        self._Checkgame()\', \'        self.function()\', \'        for event in pygame.event.get():\', \'            if event.type == pygame.QUIT:\', \'                sys.exit()\', \'        pygame.display.update()\', \'\', \'\', "if __name__ == \'__main__\':", \'    pygame.init()\', \'    screen = pygame.display.set_mode((500,500))\', \'    center: Coordinate = pygame.display.get_window_size()[0]/2, pygame.display.get_window_size()[1]/2\', \'    Base.screenColor = (255,255,255)\', \'    Base.quitImageOption = True\', \'    @Base\', \'    def game() -> None: ...\', \'    run = True\', \'    while run:\', \'        game()\', \'        #print(Base.cache_info())\']])\r\n', b'with open("NTSModule/pygameNTS/ButtonClasses/ButtonAnim.py", "w") as ButtonAnimFile:\r\n', b'    ButtonAnimFile.writelines([f"{x}\\n" for x in [\'import pygame, sys, os, logging\', \'sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))\', \'sys.path.append(os.path.dirname(os.path.dirname(__file__)))\', \'pygame.init()\', \'from imports import *\', \'from pygVariables import *\', \'from pygFuncs import *\', \'from Print import Print\', \'from ButtonClasses.ButtonImage import ButtonImage\', \'\', \'class ButtonAnim:\', \'    def __init__(\', \'            self,\', \'            imageUp: ButtonImage,\', \'            imageDown: ButtonImage\', \'    ) -> None:\', \'        if type(imageUp) is not ButtonImage:\', \'            logging.error(f"{IncorrectArgsError.__name__}")\', \'            raise IncorrectArgsError(f"Variables \\\'{CYAN}imageUp{RESET}\\\' has to be type {DGREEN}{ButtonImage.__name__}{RESET} not type {DGREEN}{type(imageUp).__name__}{RESET}.")\', \'        elif type(imageDown) is not ButtonImage:\', \'            logging.error(f"{IncorrectArgsError.__name__}")\', \'            raise IncorrectArgsError(f"Variables \\\'{CYAN}imageDown{RESET}\\\' has to be type {DGREEN}{ButtonImage.__name__}{RESET} not type {DGREEN}{type(imageUp).__name__}{RESET}.")\', \'        # Variables\', \'        self.imageUp = imageUp\', \'        self.imageDown = imageDown\', \'        self.clicked = False\', \'        self.rect: Rect = pygame.Rect((self.imageUp.imageRect.x, self.imageUp.imageRect.y), (self.imageUp.imageRect.width, self.imageUp.imageRect.height))\', \'    def call(self, surface) -> None:\', \'        self.imageUp._click()\', \'        if self.imageUp.clicked:\', \'            self.imageDown.draw(surface)\', \'        else:\', \'            self.imageUp.draw(surface)\', \'        self.clicked = self.imageUp.clicked\', \'    def click(self) -> bool:\', \'        return self.imageUp.click()\', \'\', "if __name__ == \'__main__\':", \'    ...\']])\r\n', b'with open("NTSModule/pygameNTS/ButtonClasses/ButtonImage.py", "w") as ButtonImageFile:\r\n', b'    ButtonImageFile.writelines([f"{x}\\n" for x in [\'import pygame, sys, os, logging\', \'sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))\', \'sys.path.append(os.path.dirname(os.path.dirname(__file__)))\', \'pygame.init()\', \'from imports import *\', \'from pygVariables import *\', \'from pygFuncs import *\', \'from Print import Print\', \'\', \'\', \'class ButtonImage:\', \'    @overload\', \'    def __init__(self, image: Surface, pos: Coordinate) -> None: ...\', \'    @overload\', \'    def __init__(self, image: filePath, pos: Coordinate) -> None: ...\', \'    @overload\', \'    def __init__(self, image: Surface | filePath, pos: Coordinate, scale: int) -> None: ...\', \'    @overload\', \'    def __init__(self, image: Surface | filePath, pos: Coordinate, scale: int, elevation: int) -> None: ...\', \'    def __init__(\', \'            self,\', \'            image: Surface | filePath,\', \'            pos : Coordinate,\', \'            scale: int = 1,\', \'            elevation: Optional[int] = None\', \'    ) -> None:\', \'        # Image\', \'        if type(image) is Surface:\', \'            self.image: Surface = image\', \'        elif type(image) is str:\', \'            self.image: Surface = pygame.image.load(image).convert_alpha()\', \'        else:\', \'            logging.error(f"{TypeError.__name__}")\', \'            raise TypeError(f"Variable \\\'{CYAN}image{RESET}\\\' has to be type {DGREEN}pygame{WHITE}.{DGREEN}Surface{RESET} or {DGREEN}str{RESET} not type {DGREEN}{type(image).__name__}{RESET}.")\', \'        self.image = pygame.transform.scale(self.image, (int(self.image.get_width() * scale), int(self.image.get_height() * scale)))\', \'        self.imageRect = self.image.get_rect()\', \'        self.imageMask = pygame.mask.from_surface(self.image)\', \'        self.imageRect.center = pos\', \'        self.ORimageRectY = self.imageRect.y\', \'        # Elevation\', \'        self.elevation: int = elevation\', \'        self.dElev: int = elevation\', \'        if self.elevation is not None:\', \'            self.EleRect: Rect = pygame.Rect((0,0), (self.image.get_width(), self.image.get_height()))\', \'        # Extra variables\', \'        self.pos: Coordinate = pos\', \'        self.clicked = False\', \'        self.down = False\', \'    \', \'    @overload\', \'    def draw(self, surface: Surface) -> None: ...\', \'    @overload\', \'    def draw(self, surface: Surface, edge: int) -> None: ...\', \'    def draw(\', \'            self,\', \'            surface: Surface,\', \'            edge: int = 0\', \'    ) -> None:\', \'        self.__elevation(surface, edge)\', \'        surface.blit(self.image, self.imageRect)\', \'        self.__click()\', \'    \', \'    def __elevation(\', \'            self,\', \'            surface: Surface,\', \'            edge: int\', \'    ) -> None:\', \'            if self.elevation is not None:\', \'                if type(self.elevation) is not int:\', \'                    logging.error(f"{IncorrectArgsError.__name__}")\', \'                    raise IncorrectArgsError(f"Variable \\\'{CYAN}elevation{RESET}\\\' can only be type {DGREEN}int{RESET} not {DGREEN}{type(self.elevation).__name__}{RESET}.")\', \'                self.imageRect.y = self.ORimageRectY - self.elevation\', \'                self.EleRect.height = self.imageRect.height + self.elevation\', \'                self.EleRect.midtop = self.imageRect.midtop\', \'                pygame.draw.rect(surface, (0,0,0), self.EleRect, border_radius=edge)\', \'                self.__changingElev()\', \'\', \'    def __changingElev(self) -> None:\', \'        if self.imageRect.collidepoint(variables()[0]) and variables()[1][0]:\', \'            self.elevation = 0\', \'        else:\', \'            self.elevation = self.dElev\', \'    \', \'    def _click(self) -> None:\', \'        """Used by other classes to change this classes variable self.clicked"""\', \'        if self.imageRect.collidepoint(variables()[0]) and variables()[1][0] and self.clicked is False:\', \'            self.clicked = True\', \'        else:\', \'            if variables()[1][0] is False:\', \'                self.clicked = False\', \'    \', \'    def __click(self) -> None:\', \'        if self.imageRect.collidepoint(variables()[0]) and variables()[1][0] and self.clicked is False:\', \'            self.clicked = True\', \'        else:\', \'            if variables()[1][0] is False:\', \'                self.clicked = False\', \'\', \'    def click(self) -> bool:\', \'        if self.imageRect.collidepoint(variables()[0]) and variables()[1][0] and self.down is False:\', \'            self.down = True\', \'        elif self.down is True and self.imageRect.collidepoint(variables()[0]) and variables()[1][0] is False:\', \'            self.down = False\', \'            return True\', \'        elif self.down is True and self.imageRect.collidepoint(variables()[0]) is False:\', \'            self.down = False\', \'            return False\', \'        return False\', \'        \', \'        \', \'\', \'        \', \'        \', \'\', "if __name__ == \'__main__\':", \'    pygame.init()\', \'    screen = pygame.display.set_mode((500,500))\', \'    center: Coordinate = pygame.display.get_window_size()[0]/2, pygame.display.get_window_size()[1]/2\', \'    x = ButtonImage("C:/Users/jwjnt/Desktop/GitLab/NTS_Module2/Images/button spritesheet.png", center, 2)\', \'    run = True\', \'    while run:\', \'        screen.fill((255,255,255))\', \'        \', \'        if x.click():\', \'            print("BOOM")\', \'\', \'        x.draw(screen)\', \'        #print(x.buttonRect.center, x.elevation)\', \'        for event in pygame.event.get():\', \'            if event.type == pygame.QUIT:\', \'                sys.exit()\', \'        pygame.display.update()\', \' \']])\r\n', b'with open("NTSModule/pygameNTS/ButtonClasses/StripC.py", "w") as StripCFiles:\r\n', b'    StripCFiles.writelines([f"{x}\\n" for x in [\'import pygame, os, sys, logging\', \'sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))\', \'sys.path.append(os.path.dirname(os.path.dirname(__file__)))\', \'pygame.init()\', \'from imports import *\', \'from pygVariables import *\', \'from pygFuncs import *\', \'from Print import Print\', \'\', \'\', \'widthEach = int\', \'heightEach = int\', \'frameStartEach = Coordinate\', \'\', \'\', \'\', \'class StripC:\', \'    image: filePath | Surface\', \'    width : int\', \'    height: int\', \'    frameStart : int\', \'    @overload\', \'    def __init__(self, image: filePath) -> None: ...\', \'    @overload\', \'    def __init__(self, image: Surface) -> None: ...\', \'    def __init__(\', \'            self,\', \'            image: Surface | filePath\', \'    ) -> None:\', \'        if type(image) is Surface:\', \'            self.imageInput = image\', \'        elif type(image) is str:\', \'            self.imageInput: Surface = pygame.image.load(image).convert_alpha()\', \'        else:\', \'            logging.error(f"{IncorrectArgsError.__name__}")\', \'            raise IncorrectArgsError(f"Argument \\\'{CYAN}image{RESET}\\\' has to be type {DGREEN}pygame.Surface{RESET} or {DGREEN}str{RESET} not type {DGREEN}{type(image).__name__}{RESET}.")\', \'\', \'    @overload\', \'    def strip(self, width: int, height: int) -> Surface: """"""\', \'    @overload\', \'    def strip(self, width: int, height: int, frameStart: Coordinate) -> Surface: """"""\', \'    @overload\', \'    def strip(self, listOfImages: list[tuple[widthEach: int, heightEach: int, frameStartEach: Coordinate]]) -> list[Surface]: """Must use keyword argument \\\'listOfImages\\\' and no other arguments."""\', \'\', \'    def strip(\', \'            self,\', \'            width: Optional[int] = None,\', \'            height: Optional[int] = None,\', \'            frameStart: Coordinate = (0,0),\', \'            listOfImages: Optional[list[tuple[widthEach, heightEach, frameStartEach]]] = None\', \'    ) -> Surface:\', \'        if listOfImages is None:\', \'            if width is None or height is None:\', \'                logging.error(f"{UnknownVars.__name__}")\', \'                raise UnknownVars(f"Variables \\\'{CYAN}width{RESET}\\\' or \\\'{CYAN}{height}{RESET}\\\' were not given.")\', \'            strippedImage: Surface = pygame.Surface((width, height))\', \'            strippedImage.blit(self.imageInput, (0,0), (frameStart, (width, height)))\', \'            strippedImage.set_colorkey((0,0,0))\', \'            return strippedImage\', \'        elif type(listOfImages) is list:\', \'            if width is not None or height is not None or frameStart != (0,0):\', \'                logging.error(f"{IncompatableArgsError.__name__}")\', \'                raise IncompatableArgsError(f"Arguments \\\'{CYAN}width{RESET}\\\' or \\\'{CYAN}height{RESET}\\\' or \\\'{CYAN}frameStart{RESET}\\\' cannot be given while \\\'{CYAN}listOfImages{RESET}\\\' is given.")\', \'            listOfSurfaces = []\', \'            for w,h,f in listOfImages:\', \'                image: Surface = pygame.Surface((w,h))\', \'                image.blit(self.imageInput, (0,0), (f, (w,h)))\', \'                image.set_colorkey((0,0,0))\', \'                listOfSurfaces.append(image)\', \'            return listOfSurfaces\', \'        elif type(listOfImages) is not list:\', \'            logging.error(f"{IncorrectArgsError.__name__}")\', \'            raise IncorrectArgsError(f"Argument \\\'{CYAN}listOfImages{RESET}\\\' has to be type {DGREEN}list{WHITE}[{DGREEN}tuple{WHITE}[{DGREEN}int{WHITE}, {DGREEN}int{WHITE}, {CYAN}Coordinate{WHITE}]{WHITE}]{RESET} not type {DGREEN}{type(listOfImages).__name__}{RESET}")\', \'        else:\', \'            logging.error(f"{UnknownError.__name__}")\', \'            raise UnknownError(f"This error was called from {DGREEN}StripC{WHITE}.{YELLOW}strip{WHITE}(){RESET}.")\']])\r\n', b'with open("NTSModule/pygameNTS/ButtonClasses/Button.py", "w") as ButtonFile:\r\n', b'    ButtonFile.writelines([f"{x}\\n" for x in [\'import pygame, sys, os, logging\', \'sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))\', \'sys.path.append(os.path.dirname(os.path.dirname(__file__)))\', \'pygame.init()\', \'from imports import *\', \'from pygVariables import *\', \'from pygFuncs import *\', \'from Print import Print\', \'\', \'\', \'\', \'class Button:\', \'    @overload\', \'    def __init__(self, text:str, buttonColor: ColorRBG, pos: Coordinate) -> None: ...\', \'    @overload\', \'    def __init__(self, text: str, buttonColor: ColorRBG, pos: Coordinate, width: int, height: int) -> None: ...\', \'    @overload\', \'    def __init__(self, text: str, buttonColor: ColorRBG, pos: Coordinate, width: int, height: int, elevation: int) -> None: ...\', \'    @overload\', \'    def __init__(self, text: str, buttonColor: ColorRBG, pos: Coordinate, width: int, height: int, elevation: int, fontName: str, fontSize: int, fontColor: ColorRBG) -> None: ...\', \'    def __init__(\', \'            self,\', \'            text: str,\', \'            buttonColor: ColorRBG,\', \'            pos: Coordinate,\', \'            width: int = 100,\', \'            height: int = 50,\', \'            elevation: Optional[int] = None,\', \'            fontName: Optional[Font] = None,\', \'            fontSize: int = 20,\', \'            fontColor: ColorRBG = (0,0,0)\', \'    ) -> None:\', \'        # Font\', \'        self.font: Font = pygame.font.SysFont(fontName, fontSize)\', \'        self.fontColor = fontColor\', \'        # Button\', \'        self.buttonRect: Rect = pygame.Rect((0, 0),(width, height))\', \'        self.buttonRect.center = pos\', \'        self.ORButtonRectY = self.buttonRect.y\', \'        self.buttonColor: ColorRBG = buttonColor\', \'        self.ORbuttonColor = buttonColor\', \'        # Text\', \'        self.text: Surface = self.font.render(text, True, fontColor)\', \'        self.textRect: Rect = self.text.get_rect()\', \'        # Elevation\', \'        self.elevation: int = elevation\', \'        self.dElev: int = elevation\', \'        if self.elevation is not None:\', \'            self.EleRect: Rect = pygame.Rect((0,0), (width, height))\', \'        # Extra variables\', \'        self.pos: Coordinate = pos\', \'        self.clicked = False\', \'        self.down = False\', \'        \', \'\', \'    @overload\', \'    def draw(self, surface: Surface) -> None: ...\', \'    @overload\', \'    def draw(self, surface: Surface, hoverColor: ColorRBG) -> None: ...\', \'    @overload\', \'    def draw(self, surface: Surface, edge: int, borderWidth: int) -> None: ...\', \'    def draw(\', \'            self,\', \'            surface: Surface,\', \'            hoverColor: Optional[ColorRBG] = None,\', \'            edge: int = 15,\', \'            borderWidth: int = 1\', \'    ) -> None:\', \'        \', \'        if hoverColor is None:\', \'            hoverColor = hoverColorFunc(self.buttonColor)\', \'\', \'        self.__elevation(surface, edge)\', \'\', \'        self.textRect.center = self.buttonRect.center\', \'        pygame.draw.rect(surface, self.buttonColor, self.buttonRect, border_radius=edge)\', \'        surface.blit(self.text, self.textRect)\', \'\', \'        self.__drawBorder(surface, edge, borderWidth)\', \'        self.__hover(hoverColor)\', \'        self.__click()\', \'\', \'    def __elevation(\', \'            self,\', \'            surface: Surface,\', \'            edge: int\', \'    ) -> None:\', \'            if self.elevation is not None:\', \'                if type(self.elevation) is not int:\', \'                    logging.error(f"{IncorrectArgsError.__name__}")\', \'                    raise IncorrectArgsError(f"Variable \\\'{CYAN}elevation{RESET}\\\' can only be type {DGREEN}int{RESET} not {DGREEN}{type(self.elevation).__name__}{RESET}.")\', \'                self.buttonRect.y = self.ORButtonRectY - self.elevation\', \'                self.EleRect.height = self.buttonRect.height + self.elevation\', \'                self.EleRect.midtop = self.buttonRect.midtop\', \'                pygame.draw.rect(surface, (0,0,0), self.EleRect, border_radius=edge)\', \'                self.__changingElev()\', \'\', \'    def __changingElev(self) -> None:\', \'        if self.buttonRect.collidepoint(variables()[0]) and variables()[1][0]:\', \'            self.elevation = 0\', \'        else:\', \'            self.elevation = self.dElev\', \'\', \'    def __drawBorder(\', \'            self, \', \'            surface: Surface, \', \'            edge: int, \', \'            borderWidth: int\', \'    ) -> None:\', \'        if borderWidth > 0:\', \'            borderRect: Rect = pygame.Rect((0,0), (self.buttonRect.width,self.buttonRect.height))\', \'            borderRect.center = self.buttonRect.center\', \'            pygame.draw.rect(surface, (0,0,0), borderRect, border_radius=edge, width=borderWidth)\', \'\', \'    def __hover(\', \'            self,\', \'            hoverColor: ColorRBG\', \'    ) -> None:\', \'        if self.buttonRect.collidepoint(variables()[0]):\', \'            self.buttonColor = hoverColor\', \'        else:\', \'            self.buttonColor = self.ORbuttonColor\', \'\', \'\', \'    def _click(self) -> None:\', \'        """Used by other classes to change this classes variable self.clicked"""\', \'        if self.buttonRect.collidepoint(variables()[0]) and variables()[1][0] and self.clicked is False:\', \'            self.clicked = True\', \'        else:\', \'            if variables()[1][0] is False:\', \'                self.clicked = False\', \'    \', \'    def __click(self) -> None:\', \'        if self.buttonRect.collidepoint(variables()[0]) and variables()[1][0] and self.clicked is False:\', \'            self.clicked = True\', \'        else:\', \'            if variables()[1][0] is False:\', \'                self.clicked = False\', \'\', \'    def click(self) -> bool:\', \'        if self.buttonRect.collidepoint(variables()[0]) and variables()[1][0] and self.down is False:\', \'            self.down = True\', \'        elif self.down is True and self.buttonRect.collidepoint(variables()[0]) and variables()[1][0] is False:\', \'            self.down = False\', \'            return True\', \'        elif self.down is True and self.buttonRect.collidepoint(variables()[0]) is False:\', \'            self.down = False\', \'            return False\', \'        return False\', \'\', \'\', "if __name__ == \'__main__\':", \'    pygame.init()\', \'    screen = pygame.display.set_mode((500,500))\', \'    center: Coordinate = pygame.display.get_window_size()[0]/2, pygame.display.get_window_size()[1]/2\', \'    x = Button("test", (255,0,255), center, fontName="Arial", elevation=10)\', \'    run = True\', \'    while run:\', \'        screen.fill((255,255,255))\', \'        \', \'        if x.click():\', \'            print("BOOM")\', \'\', \'        x.draw(screen, borderWidth=1, hoverColor=hoverColorFunc((255,0,255), allColors=True))\', \'        #print(x.buttonRect.center, x.elevation)\', \'        for event in pygame.event.get():\', \'            if event.type == pygame.QUIT:\', \'                sys.exit()\', \'        pygame.display.update()\']])\r\n'])
    os.system("python createModule.py")
    os.remove("createModule.py")
except Exception as e:
    if type(e) is PermissionError:
        print("Error: Permission denied, please run this code using IDLE or VSCode.")
        input()
    else:
        waitexcepthook(Exception, e, Exception)